<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Code, data and ML</title>
	<subtitle>I am writing about my experiences as a naval navel-gazer.</subtitle>
	<link href="https://sami-badawi.github.io/feed.xml" rel="self"/>
	<link href="https://sami-badawi.github.io/"/>
	
	<updated>2023-05-22T12:19:20Z</updated>
	<id>https://sami-badawi.github.io/</id>
	<author>
		<name>Sami Badawi</name>
		<email>sami.badawi@gmail.com</email>
	</author>
	<entry>
		<title>Language Pick for 2023</title>
		<link href="https://sami-badawi.github.io/posts/language-pick-2023/"/>
		<updated>2023-05-04T00:00:00Z</updated>
		<id>https://sami-badawi.github.io/posts/language-pick-2023/</id>
		<content type="html">&lt;h1&gt;Many languages are converging on a common feature set&lt;/h1&gt;
&lt;p&gt;I love languages and every language has some great features, but also some very annoying ones.
Python and Scala were the first languages where I felt that the good parts overshadow the bad parts. They really improved my productivity.&lt;/p&gt;
&lt;p&gt;In 2023 most mainstream languages have adapted successful ideas from other languages. And they have all become pretty good.&lt;/p&gt;
&lt;h1&gt;Language I have used in early 2023&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Bash&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Bourne shell&lt;/h2&gt;
&lt;p&gt;I have been using Bourne shell for writing scripts and cloud work.&lt;/p&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;p&gt;I have been using Python for doing ML / A.I. and for writing api.&lt;/p&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;p&gt;I have been using Rust for serving PyTorch models.&lt;/p&gt;
&lt;h2&gt;Scala&lt;/h2&gt;
&lt;p&gt;I have been using Scala for writing data pipelines in Flink.&lt;/p&gt;
&lt;h2&gt;TypeScript&lt;/h2&gt;
&lt;p&gt;I think that TypeScript has the most powerful type system of all mainstream languages.
But last I used it, getting the tooling working was still too much work.&lt;/p&gt;
&lt;p&gt;Now both Deno and Bun.sh have TypeScript support out of the box.
I have been using TypeScript for handling json and for doing a little front end work using Deno libraries.&lt;/p&gt;
&lt;h1&gt;Language I would like to use more&lt;/h1&gt;
&lt;h2&gt;C#&lt;/h2&gt;
&lt;p&gt;.NET is a great platform and C# is a great language, for GUI work this is my first choice.&lt;/p&gt;
&lt;h2&gt;Lean 4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leanprover/lean4&quot;&gt;Lean 4&lt;/a&gt; is a proof assistant and a Haskell-like functional programming language. It is based on dependent types and has a very powerful type system.&lt;/p&gt;
&lt;p&gt;Mathematicians are using Lean 4 to prove theorems.&lt;/p&gt;
&lt;p&gt;Lean 4 has fixed some of the warts in Haskell, and I think that the combination of theorem prover and a functional programming language could prove useful for A.I. applications.&lt;/p&gt;
&lt;h2&gt;Nim&lt;/h2&gt;
&lt;p&gt;I tried Nim last year and I was impressed. It looked a lot like Python and it was fast like C.
However the library support is still limited. Nim shows that you do not have to choose between fast and simple.&lt;/p&gt;
&lt;h2&gt;Zig&lt;/h2&gt;
&lt;p&gt;Zig is a new generation of systems programming language. It is a lot like C, but with a much better type system.&lt;/p&gt;
&lt;p&gt;It is also a build system that you can compile C and C++ code with.
You write your build script in Zig and not in CMake, this gives it a lot of power.&lt;/p&gt;
&lt;p&gt;I tried the Ziglang game engine, &lt;a href=&quot;https://machengine.org/&quot;&gt;Mach engine&lt;/a&gt;. Mach Engine ships with several cross platform 2D and 3D demos, which compiled and ran in seconds.&lt;/p&gt;
&lt;p&gt;Getting 2D and 3D demos running in C++ took me many long weekends between learning and configuring CMake, vcpkg, GLFW, GLEW and OpenGL.&lt;/p&gt;</content>
	</entry>
	<entry>
		<title>Will A.I. Think in Logic or English</title>
		<link href="https://sami-badawi.github.io/posts/will-ai-think-logic-or-english/"/>
		<updated>2023-05-03T00:00:00Z</updated>
		<id>https://sami-badawi.github.io/posts/will-ai-think-logic-or-english/</id>
		<content type="html">&lt;h1&gt;Will A.I. Think in Logic or English&lt;/h1&gt;
&lt;p&gt;We have seen a lot of progress in A.I. during 2023. Every week something new has happened.&lt;/p&gt;
&lt;p&gt;ChatGPT is probably the most famous example. It is a chatbot that can talk about anything and generate code.&lt;/p&gt;
&lt;p&gt;I started studying A.I. during the symbolic A.I. era, and assumed that when A.I. started producing results it would eventually think in logic.
ChatGPT is a big black box consisting of billions of parameters. Trained on a huge corpus of text, by hiding a word and asking the model to predict the missing word. So the opposite of logic.&lt;/p&gt;
&lt;p&gt;While this is impressive it is hard to extract business value from this. I see two ways forward for LLMs in the near future.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return of Symbolic Logic&lt;/li&gt;
&lt;li&gt;Chat is All You Need&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Return of Symbolic Logic&lt;/h1&gt;
&lt;p&gt;We find a way to translate the result from large language models into logic, say RDF, OWL or a knowledge graph.
This is a good medium for storing large amounts of knowledge in a form that you can query and reason about.&lt;/p&gt;
&lt;h1&gt;Chat is All You Need&lt;/h1&gt;
&lt;p&gt;It is also possible that LLMs will reinvent some rudimentary form of logic, and that you will just be able to ask it questions.&lt;/p&gt;
&lt;p&gt;This seems like a brittle way to represent larger amounts of knowledge. In that case we would have invented a weird new form of ad hoc intelligence, that knows how to chat but is hard to reason about or have confidence in.&lt;/p&gt;</content>
	</entry>
	<entry>
		<title>Language Pick for 2019</title>
		<link href="https://sami-badawi.github.io/posts/language-pick-2019/"/>
		<updated>2019-02-25T00:00:00Z</updated>
		<id>https://sami-badawi.github.io/posts/language-pick-2019/</id>
		<content type="html">&lt;h1&gt;I did not pick them they picked me&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Bash&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Terraform&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;strong&gt;Bourne shell&lt;/strong&gt; was cutting edge in 1977, and it still is today. I have aesthetics issues with it, but it has found a new happy home in cloud computing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt; and &lt;strong&gt;Scala&lt;/strong&gt; will take you far in backend and data engineering.&lt;/p&gt;
&lt;p&gt;The gradual types in Python 3.6 and 3.7 are really a great help but they are very simple compared to TypeScript that probably has the most sophisticated type system these days.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rust&lt;/strong&gt; is beginning to make it into cloud infrastructure&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS Firecracker&lt;/li&gt;
&lt;li&gt;Fargate&lt;/li&gt;
&lt;li&gt;Google Fuchsia&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rust also seems like a natural choice for working with WebAssembly.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Terraform&lt;/strong&gt; feels like a strange combination of Haskell and TypeSafe config. But it also fills a niche in cloud computing for: Infrastructure as code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TypeScript&lt;/strong&gt; is a roubust JavaScript and unsurpassed at describing and processing complex syntactic relations using its type system.&lt;/p&gt;</content>
	</entry>
	<entry>
		<title>Languages Evolution</title>
		<link href="https://sami-badawi.github.io/posts/language-evolution/"/>
		<updated>2019-02-24T00:00:00Z</updated>
		<id>https://sami-badawi.github.io/posts/language-evolution/</id>
		<content type="html">&lt;h1&gt;Languages Evolution with Poetic License&lt;/h1&gt;
&lt;p&gt;Looking at language evolution over many years I lost count of how many times I fell in love with a new language and thought this was the ultimate language.&lt;/p&gt;
&lt;p&gt;Here are my initial impressions for some mainstream languages that I really liked:&lt;/p&gt;
&lt;h2&gt;C++&lt;/h2&gt;
&lt;p&gt;The one true programming language of the day.
With the awesome power of OOP.&lt;/p&gt;
&lt;h2&gt;Java&lt;/h2&gt;
&lt;p&gt;The untimate language to end all languages.
It had everything that was cool in 1994.&lt;/p&gt;
&lt;h2&gt;C#&lt;/h2&gt;
&lt;p&gt;The perfect language that cleaned up everything that went wrong in Java.&lt;/p&gt;
&lt;h2&gt;Perl&lt;/h2&gt;
&lt;p&gt;They lied to me!&lt;/p&gt;
&lt;p&gt;You don’t need design patterms and OOP.&lt;/p&gt;
&lt;p&gt;You can hack it out in 10 lines of Perl.&lt;/p&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;p&gt;Hey you don’t need to hack it out in 10 lines of Perl.
You can program it in 15 lines of Python.&lt;/p&gt;
&lt;h2&gt;Scala&lt;/h2&gt;
&lt;p&gt;Theoretical CS and type theory is not just for academia.
A gem of a orthogonal, minimal constructs.
Safe, elegant, fast and happy.&lt;/p&gt;
&lt;h2&gt;Haskell&lt;/h2&gt;
&lt;p&gt;Wow it is possible to program in mathematics. I did it! I scaled mount Haskell and took a snapshot and wrote a blog post.&lt;/p&gt;
&lt;h2&gt;TypeScript&lt;/h2&gt;
&lt;p&gt;You do not have to chose between type based language and dynamic data language.
You can have both.&lt;/p&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;p&gt;At a low level the computer industry is build on a very insecure foundation.
Type theory can make lowlevel code very fast, safe and elegant.&lt;/p&gt;</content>
	</entry>
</feed>
